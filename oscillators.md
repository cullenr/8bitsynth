% 8-bit Oscillators
% Rory C
% date

1. naive oscillator
2. Nyquist
3. Harmonics
5. Band limiting
4. Additive fourier series https://en.wikipedia.org/wiki/Fourier_series
6. wave tables
7. polyBlep


# Intro

In this article we will explore different methods that can be used to generate
audio waveforms. We will cover oscillators, additive synthesis and wavetable
synthesis. Our goal is to find a suitable tone generator for an MCU running at
a low bitrate and low sampling rate.

## Waveforms

In audio synthesis there are four common waveforms that are used as the basis of
most sounds; sine, square, triangle and sawtooth.

```{#fig:waveforms .gnuplot format=SVG source=true}
set terminal svg size 800,600 dynamic lw 2 font "sans,16"

set xlabel 'phase ϕ'
set ylabel 'amplitude A'

set xrange [0:2*pi]
set yrange [-1.5:1.5]

set xtics (0, 'π' pi, '2π' 2*pi)
set ytics 1

_sin(x) = sin(x)
_saw(x) = 1 - x / pi
_sqr(x) = x >= pi ? 1 : -1
_tri(x) = x <= pi ? -1 + x * 2 / pi : 3 - x * 2 / pi

# Plot
plot _sin(x) title 'sin' with lines, \
     _saw(x) title 'saw' with lines, \
     _sqr(x) title 'square' with lines, \
     _tri(x) title 'triangle' with lines 
```

@fig:waveforms shows the amplitude response of each oscillator over the relative
time it takes to complete one cycle of a waveform; _2π_.


## Naive Oscillator

$ \delta\phi = (2 pi f)/F $

There are three important properties to consider when writing an oscillator;
Note-Frequency, Sample-Rate and Phase. 

Looping the waveforms in _fig 1_ at frequencies in the audio range (~20Hz to
~20kz) will produce notes we can hear. This is our Note-Frequency, which we will
represent with a lowercase '_f_' in our formula. Note frequency is measured in
cycles per second, also known as Hertz

[
Phase can be used to express any given point along a single cycle of a waveform,
it is measured in Radians. It is often denoted by the _phi_ symbol 'ϕ' and in
our case has a range of 0 to 2π.

If the Note Frequency is a subdivision of 1 second into loops of a
waveform, we can think of phase as a portion of a single cycle of our Note
Frequency. Instead of measuring Phase in Hertz like Note Frequency we measure
Phase in Radians, in this case the range is 0 to 2π.
]

Sin waves can be generated by periodically _sampling_ the math function _sin_ in
a loop. The loop assumes that a fixed amount of time has passed between each
iteration, this delta time is governed by the Sample Rate. If the sample rate is
set to 44.1khz the loop will iterate 44100 times per second\*, each sample will
therefore represent 1/44100th of a second of audio as the samples are
distributed evenly.

> \* In most practical applications a buffer is implemented and the loop does not
>   run in real time.

As our starting point we will write an oscillator that generates a sinusoidal
waveform at a constant frequency. Our program will output raw 8bit PCM which we
can use other software to inspect, this will save some time and typing.

```c
#include <math.h>
#include <stdio.h>
#include <stdint.h>

int main(void) {
    const double duration      = 1;    // seconds of audio
    const uint32_t sample_rate = 8000; // samples per second
    const uint32_t num_samples = duration * sample_rate;

    // the audio note in Hz that we wish to produce (note A4)
    const double freq = 440;
    // the size of a step in radians to produce our note at our sample rate
    const double step = 3.14159 * freq / sample_rate;
    // this is our phase accumulator
    double phase = 0;

    for(int i = 0; i < num_samples; i++) {
        // sample the sin function, this will return a value in the range of 
        // 1.0 to -1.0
        const double sample = sin(phase);
        // convert the sample from 1.0 to -1.0 to the range of 256 to 0
        const uint8_t byte = ((sample + 1.0) / 2.0) * 256.0; 
        printf("%c", byte);

        // increment the phase for the next iteration
        phase += step;
    }

    return 0;
}
```

Compile this like so:

    gcc naive-sqr.c -lm -o sin

The above command will produce a program that produces a PCM stream that we can
inspect using various methods. In the following example we are using the `play`
program from the `sox` library to play the PCM stream as audio. Note the command
line flags that provide the metadata that would otherwise be an audio file
header.

<figure>
    <figcaption>440Hz Sin wave</figcaption>
    <audio controls src="./sin440.wav"> </audio> 
</figure>

    play -t raw -r 8k -e unsigned -b 8 -c 1 <(./sin)

A PCM stream is simply a stream of Amplitude values. If we plot the amplitude
values on the y axis of a graph we can produce a familiar waveform plot:

<figure>
    <img src="./naive-sin-waveform.svg">
    <figcaption>fig 2</figcaption>
</figure>

    sox -t raw -r 8k -e unsigned -b 8 -c 1 <(./sin) -t dat - |\
    awk 'NR==3, NR==65 {print $0}' |\
    gnuplot -e "set terminal png size 800,600; plot '-' with linespoints" |\
    display


A possibly less familiar representation of the audio is the power spectrum. This
shows the harmonic content of the audio. The y axis shows the power or amplitude
of any given frequency along the x axis.


<figure>
    <img src="./naive-sin-fpower.svg">
    <figcaption>fig 3</figcaption>
</figure>

    sox -t raw -r 8k -e unsigned -b 8 -c 1 <(./sin) -n stat -freq 2>&1 |\
    head -n -17 |\
    gnuplot -e 'set terminal png size 800,600; plot "-" with impulses' |\
    display

## Harmonics

The _sin_ program above attempts to produce a pure sine wave. Sin waves are
special in that they have energy at one particular frequency, this is shown in
_fig 3_ where we can see a distinct peak at 440Hz. More complex sounds contain
extra energy at multiple frequencies, this gives them a distinct timbre.

Square, Triangle and Sawtooth waveforms all contain harmonics/ partials above
the root frequency. In these particular waveforms the distributions of these
partials are neatly spaced, more on this later. 

For now lets use the amplitude over time data in _fig 1_ as a guide for adding
these new wave shapes to our tone generator. The following extract from
[this](./naive-mulit.c) program shows further naive implementations of these
waves shapes.

```c
...
    for(int i = 0; i < num_samples; i++) {
        uint8_t byte;
        switch(wave) {
            case SIN:
                byte = ((sin(phase) + 1.0) / 2.0) * 255.0; 
                break;
            case SQR:
                byte = phase < PI ? 0x00 : 0xFF; 
                break;
            case TRI: 
                byte= phase < PI 
                    ? phase / PI * 255.0
                    : 511 - phase / PI * 255.0;
                break;
            case SAW:
                byte = phase / PI2 * 255; 
                break;
            default:
                fprintf(stderr, "unknown wave type! %d", wave);
                exit(EXIT_FAILURE);
        }

        printf("%c", byte);

        phase += step;
        while (phase > PI2) 
            phase -= PI2;
    }
...
```

$ saw(t) = (2A)/pi \sum_{k=1}^\infty (-1)^k \left(\frac{2 \pi k f t}{k}\right) $

<figure>
    <figcaption>110Hz Sin wave</figcaption>
    <img src="./sin110.png">
    <audio controls src="./sin110.wav"> </audio> 
</figure>
<figure>
    <figcaption>110Hz Saw wave</figcaption>
    <img src="./saw110.png">
    <audio controls src="./saw110.wav"> </audio> 
</figure>
<figure>
    <figcaption>110Hz Square wave</figcaption>
    <img src="./sqr110.png">
    <audio controls src="./sqr110.wav"> </audio> 
</figure>
<figure>
    <figcaption>110Hz Triangle wave</figcaption>
    <img src="./tri110.png">
    <audio controls src="./tri110.wav"> </audio> 
</figure>

TODO : draw the harmonics on a graph from the stderr of the additive-osc
TODO : demonstrate the nyquist foldover using the additive-osc
TODO : generate audio clips of harmonics being added together.

NOTES:

DSP:
https://en.wikibooks.org/wiki/Sound_Synthesis_Theory/Oscillators_and_Wavetables
http://www.dspguide.com/ch3/2.htm
http://metafunction.co.uk/all-about-digital-oscillators-part-2-blits-bleps/
// fast additive saw
https://www.desmos.com/calculator/wleksawmbq
// sing cosine approx
http://cabezal.com/misc/minsky-circles.html

//miller pucket transition splice osillators
https://www.youtube.com/watch?v=dQ8I9F-uj3w

BLIT
https://ccrma.stanford.edu/~stilti/papers/blit.pdf
https://www.music.mcgill.ca/~gary/307/week5/bandlimited.html

MINBLEP
http://www.cs.cmu.edu/~eli/papers/icmc01-hardsync.pdf
https://www.experimentalscene.com/articles/minbleps.php

POLYBLEP
http://www.martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/

